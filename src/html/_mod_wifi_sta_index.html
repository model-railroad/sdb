<html><head>
    <link rel="shortcut icon" href="data:," />
    <style>
        .warn { background-color: rgb(255, 128, 128);}
        .hide { display: none }
        .capitalize::first-letter {
            text-transform:capitalize;
        }
    </style>
    <title>Software Defined Blocks</title>
</head><body>
<h1>Software Defined Blocks</h1>
<p id="st_warn">SDB Status: <span id="st">Loading...</span></p>

<hr>
<h2>List of Blocks</h2>

<div id="block_list">Placeholder</div>

<hr>
<h2>List of Sensors</h2>

<div id="sensor_list">Placeholder</div>

<hr>
<h2>List of Servers</h2>

<div id="server_list">Placeholder</div>

<hr>

<div class="hide" id="template_group">
<h3 class="capitalize" id="title_">@Type '@Name'</h3>

Properties:
<form id="form_" enctype="text/plain" method="post">
    <table>
        <thead><tr>
            <th>Name</th>
            <th>Value</th>
        </tr></thead>
        <tbody></tbody>
    </table>
    <button type="submit">Update Changes</button>
</form>
</div>

<table class="hide">
<tr class="hide" id="template_tr">
    <td><label for="prop_" id="label_" title="@Prop">@Label</label></td>
    <td><input type="text" id="prop_" value="@Value"></td>
</tr>
</table>

<script>
    function fillText(id, value) {
        const element = document.getElementById(id);
        element.textContent = value;
    }

    function statusWarning(warn, text) {
        fillText("st", text);
        const element = document.getElementById("st_warn");
        if (warn) {
            element.classList.add("warn");
        } else {
            element.classList.remove("warn");
        }
    }

    async function onSubmit(event, type, name) {
        event.preventDefault();
        statusWarning(false, "Submitting... " + type + " " + name);

        const form = document.getElementById("form_" + type + "_" + name);
        const data = new FormData(form);

        console.log("@@ SUBMIT DATA for " + type + " " + name + " : " + JSON.stringify(data.entries()));
    }

    function createList(type, names) {
        console.log("@@ createList for " + type + " with "  + JSON.stringify(names));
        const container = document.getElementById(type + "_list");
        const template_group = document.getElementById("template_group");

        container.innerText = "";

        if (names === undefined) return;
        names.forEach((name) => {
            const group = template_group.cloneNode(/*deep=*/ true);
            group.classList.remove("hide");
            group.id = "group_" + type + "_" + name;

            let title = group.querySelector("#title_");
            title.id = "title_" + type + "_" + name;
            let t = title.innerText;
            t = t.replace("@Type", type);
            t = t.replace("@Name", name);
            title.innerText = t;

            let form = group.querySelector("#form_");
            form.id = "form_" + type + "_" + name;

            form.addEventListener("submit", (event) => onSubmit(event, type, name) );

            container.appendChild(group);
        });
    }

    async function fillListName(type, name) {
        const response = await fetch("/props?t=" + type + "&n=" + name);
        if (response.ok) {
            const template_tr = document.getElementById("template_tr");
            const tbody = document.querySelector("#form_" + type + "_" + name + " tbody");

            const data = await response.json();
            console.log("@@ /props RESULT : " + JSON.stringify(data));

            const props = data.props || {};

            for (const [prop, values] of Object.entries(props)) {
                const label = values.l || "";
                const value = values.v || "";

                const prop_id = type + "_" + prop.replaceAll(/[^a-z]+/g, "_");

                const tr = template_tr.cloneNode(/*deep=*/ true);
                tr.classList.remove("hide");
                tr.id = "tr_" + prop_id;

                let elem_label = tr.querySelector("#label_");
                elem_label.id = "label_" + prop_id;
                elem_label.htmlFor = "prop_" + prop_id;
                elem_label.innerText = elem_label.innerText.replace("@Label", label);
                elem_label.title = prop;

                let elem_input = tr.querySelector("#prop_")
                elem_input.id = "prop_" + prop_id;
                elem_input.name = prop;
                elem_input.setAttribute("value", value);

                tbody.appendChild(tr);
            }
        }
    }

    async function fillList(type, names) {
        if (names === undefined) return;
        names.forEach((name) => fillListName(type, name) );
    }

    async function load() {
        const response = await fetch("/get");
        if (response.ok) {
            try {
                const data = await response.json();
                console.log("@@ /get RESULT : " + JSON.stringify(data));

                createList("block", data.blocks);
                createList("sensor", data.sensors);
                createList("server", data.servers);

                await fillList("block", data.blocks);
                await fillList("sensor", data.sensors);
                await fillList("server", data.servers);

                statusWarning(false, data.st || "Not Configured Yet.");
                return;
            } catch(e) {
                console.log("@@ fetch error : " + JSON.stringify(e));
                throw(e);
            }
        }
        statusWarning(true, "Failed to load data from SDB.");
    }

    // async function onSubmit(event) {
    //     event.preventDefault();
    //     statusWarning(false, "Submitting...");
    //
    //     const form = document.getElementById("fm");
    //     const data = new FormData(form);
    //
    //     // Validate form content
    //     const ls = data.get("ls") || "";
    //     const pw = convertPw(data.get("pw") || "");
    //     if (ls === "") {
    //         statusWarning(true, "Please select a WiFi network.");
    //         return;
    //     } else if (ls.at(0) === "E" && pw === "") {
    //         statusWarning(true, "A password is required for '" + ls.substring(1) + "'");
    //         return;
    //     }
    //
    //     const payload = JSON.stringify({ ls, pw });
    //     const response = await fetch("/set", {
    //         method: "POST",
    //         cache: "no-cache",
    //         headers: { "Content-Type": "application/json" },
    //         body: payload,
    //     });
    //     if (response.ok) {
    //         try {
    //             const data = await response.json();
    //             statusWarning(false, data.st || "??");
    //             return;
    //         } catch (e) {
    //             console.log("@@ fetch error : " + JSON.stringify(e));
    //         }
    //     }
    //     statusWarning(true, "Failed to load data from SDB.");
    // }

    // function registerForm() {
    //     const form = document.getElementById("fm");
    //     form.addEventListener("submit", onSubmit);
    // }

    function init() {
        load();
        //registerForm();
    }

    window.addEventListener("load", (event) => init());
</script>
</body></html>
